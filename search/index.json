[{"content":"引言 CMake 是一个跨平台的构建系统生成器，用于自动化构建、测试和打包软件项目的过程。CMake 通过一系列源代码文件和配置设置，生成平台特定的构建文件（例如 Makefile、Visual Studio 项目文件等）。\nCMake语法 依次使用以下命令生成项目(对于CmakeLists.txt) 1 2 cmake -B build # 创建build文件夹和相关文件 cmake --build build # 生成项目 语法简介\ncmake -P *.cmake命令来运行cmake文件\n1 2 3 4 5 6 7 8 9 10 11 12 # 单行打印 message(\u0026#34;hello\u0026#34;) message(hello) # 多行打印 message(\u0026#34;first line second line\u0026#34;) message([[first line second line]]) # 打印cmake版本号，使用CMAKE_VERSION变量 ${} message(${CMAKE_VERSION}) set设置变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 set(Var1 \u0026#34;hello\u0026#34;) set(Var2 world) # 打印单行hello world message(${Var1} ${Var2}) # 打印多行hello world message(\u0026#34;${Var1} ${Var2}\u0026#34;) message(\u0026#34;------------------------\u0026#34;) set(VarLists a1 a2) message(${VarLists}) #a1a2 # 打印环境变量 message($ENV{PATH}) # 创建cmake项目的环境变量 set(ENV{CXX} \u0026#34;g++\u0026#34;) message($ENV{CXX}) # 删除刚刚创建的环境变量 unset(ENV{CXX}) list\nlist(操作方式 操作对象 可能有操作返回结果的变量) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 list(APPEND port p1 p2 p3) message(${port}) # p1p2p3 list(LENGTH port len) message(${len}) # 3 (变量长度为3) list(FIND port p2 index) message(${index}) # 1 (p2在1的位置) list(REMOVE_ITEM port p1) message(${port}) # p2p3 (删除p1) list(INSERT port 1 p2.5) message(${port}) # p2p2.5p3 (在1位置插入p2.5) list(REVERSE port) message(${port}) # p3p2.5p2 (进行反转) list(SORT port) message(${port}) # p2p2.5p3 (进行排序) 流程控制\nif流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 set(VAR1 TRUE) set(VAR2 FALSE) if(VAR1) # 简单判断 message(TRUE) else() message(FALSE) endif() if(NOT VAR1) # NOT不能是not，大小写敏感 message(TRUE) else() message(FALSE) endif() if(VAR1 AND VAR2) # OR用法也是如此 message(TRUE) else() message(FALSE) endif() if(1 LESS 2) # 比较,其实还是字符串的比较 message(\u0026#34;1 less 2\u0026#34;) else() message(\u0026#34;error\u0026#34;) endif() if(2 GREATER 1) message(\u0026#34;2 greater 1\u0026#34;) endif() if(2 EQUAL \u0026#34;2\u0026#34;) message(\u0026#34;2 equal \\\u0026#34;2\\\u0026#34;\u0026#34;) endif() for流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 foreach(VAR RANGE 3) message(${VAR}) # 0 1 2 3 (跟一般编程语言区别很大) endforeach() set(MY_LISTS 1 2 3) foreach(VAR IN LISTS MY_LISTS ITEMS 4 f) message(${VAR}) # 1 2 3 4 f endforeach() message(\u0026#34;----------------------\u0026#34;) set(L1 one two three) set(L2 1 2 3 4) foreach(num IN ZIP_LISTS L1 L2) message(\u0026#34;word = ${num_0}, num = ${num_1}\u0026#34;) endforeach() # word = one, num = 1 # word = two, num = 2 # word = three, num = 3 # word = , num = 4 ​\n函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function(MyFunc FirstArg) # 函数名MyFunc message(\u0026#34;MyFunc Name: ${CMAKE_CURRENT_FUNCTION}\u0026#34;) message(\u0026#34;FIRST ${FirstArg}\u0026#34;) # 使用形参列表使用参数 set(FirstArg \u0026#34;New value\u0026#34;) message(\u0026#34;FirstArg again: ${FirstArg}\u0026#34;) message(\u0026#34;ARGV0 ${ARGV0}\u0026#34;) # 不使用形参列表使用参数 message(\u0026#34;ARGV1 ${ARGV1}\u0026#34;) message(\u0026#34;ARGV2 ${ARGV2}\u0026#34;) endfunction() set(FirstArg \u0026#34;first value\u0026#34;) MyFunc(${FirstArg} \u0026#34;value\u0026#34;) # 可以传入和新参列表不一样数目的实参 message(\u0026#34;FirstArg ${FirstArg}\u0026#34;) # 函数内部修改不会改变函数外面 # MyFunc Name: MyFunc # FIRST first value # FirstArg again: New value # ARGV0 first value # ARGV1 value # ARGV2 # FirstArg first value 宏\n1 2 3 4 5 6 7 8 9 10 11 12 13 macro(Test myVar) set(myVar \u0026#34;new value\u0026#34;) # 新建的变量，不是上面的参数 message(\u0026#34;argument: ${myVar}\u0026#34;) #${myVar}会变为传入的myVar endmacro() set(myVar \u0026#34;First value\u0026#34;) message(\u0026#34;myVar: ${myVar}\u0026#34;) Test(\u0026#34;value\u0026#34;) # 将宏代码复制到了这里 message(\u0026#34;myVar: ${myVar}\u0026#34;) # myVar: First value # argument: value # myVar: new value 简单的CMake项目 在这个简单的CMake项目中，有如下的项目结构 整个项目只有一个CMakeLists.txt，所有的源文件和头文件都放在项目目录中，bin中存放的是最终的可执行程序。 CMakeLists.txt中的代码如下 1 2 3 4 5 6 7 cmake_minimum_required(VERSION 3.29.0) # 确定CMake版本 project(planning) # 项目名 set(CMAKE_CXX_STANDARD 17) # 使用的语言和版本 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) # 设定可执行文件的路径 aux_source_directory(. SRC_LISTS) # 添加当前目录所有源文件路径到SRC_LIST变量中 add_executable(planning_main ${SRC_LISTS}) # 通过源文件创建目标可执行文件 分文件编写的的CMake项目 在这个份文件的CMake项目中，有如下的项目结构 整个项目只有一个CMakeLists.txt，src文件夹里面存放的是源文件，include文件夹中存放的是头文件，bin中存放的是最终的可执行程序。 CMakeLists.txt中的代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 cmake_minimum_required(VERSION 3.20.0) # 确定CMake版本 project(my_hello) # 项目名 set(CMAKE_CXX_STANDARD 17) # 使用的语言和版本 include_directories(${PROJECT_SOURCE_DIR}/include) # 指定头文件搜索路径 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) # 设定可执行文件的路径 aux_source_directory(${PROJECT_SOURCE_DIR}/src SRC_LIST) # 添加src目录下所有源文件路径到SRC_LIST变量中 add_executable( # 通过源文件创建目标可执行文件 my_hello ${SRC_LIST} ) 共享库 在创建共享库的项目中，有如下目录结构 注意到bin中多出了libcommon.dll动态链接库文件。同时，main程序在项目目录下，其他.cpp文件存放在了src目录中，头文件存放在了include目录中。 CMakeLists.txt中的代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 cmake_minimum_required(VERSION 3.29.0) project(planning) set(CMAKE_CXX_STANDARD 17) # 设置生成的动态库存放路径 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin) #linux下使用 CMAKE_LIBRARY_OUTPUT_DIRECTORY 变量 #静态库使用 CMAKE_ARCHIVE_OUTPUT_DIRECTORY 变量 aux_source_directory(${PROJECT_SOURCE_DIR}/src SRC_LISTS) # 创建了名为common的动态库 add_library(common SHARED ${SRC_LISTS} ) # add_library(common STATIC ${SRC_LISTS}) 创建的是静态库 # 为动态库添加头文件目录 target_include_directories(common PUBLIC ${PROJECT_SOURCE_DIR}/include ) #生成可执行程序 add_executable(planning_main planning_main.cpp) # 为目标 planning_main 设置头文件目录 target_include_directories(planning_main PUBLIC ${PROJECT_SOURCE_DIR}/include ) # 为目标 planning_main 链接 common 库 target_link_libraries(planning_main PUBLIC common ) CmakeLists嵌套 项目有如下目录结构 项目文件夹下有一个CmakeLists文件；src文件夹里有一个CmakeLists文件，主程序和几个类的文件夹；同时src中每个类各自的文件夹都包含了CmakeLists，.cpp，.h三个文件 嵌套使用的时候上层CmakeLists文件的变量会传入到下层的CmakeLists文件当中。\n项目文件夹下的CmakeLists.txt代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cmake_minimum_required(VERSION 3.29.0) project(planning VERSION 0.0.1 DESCRIPTION \u0026#34;a demo of cmake planning\u0026#34; LANGUAGES CXX ) set(CMAKE_CXX_STANDARD 17) # 一些后面要使用的变量 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin) set(PROCESS_DIR ${CMAKE_SOURCE_DIR}/src/process) set(PNC_MAP_DIR ${CMAKE_SOURCE_DIR}/src/pnc_map) # 增加子目录 add_subdirectory(src) src文件夹下的CmakeLists.txt代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 project(planning_main) # 添加子目录 add_subdirectory(pnc_map) add_subdirectory(process) # 根据planning_main.cpp形成可执行文件 add_executable(${PROJECT_NAME} planning_main.cpp) # 生成可执行文件需要process.h target_include_directories(${PROJECT_NAME} PUBLIC ${PROCESS_DIR} ) # 链接库需要process库 target_link_libraries(${PROJECT_NAME} PUBLIC process ) 两个类中的CmakeLists代码分别如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 project(process) add_library( ${PROJECT_NAME} SHARED process.cpp ) # 生成库需要pnc_map.h\t注意，这是根据代码的关系决定，本例代码中，类process有pnc_maplei\u0026#39;x的成员变量 target_include_directories(${PROJECT_NAME} PUBLIC ${PNC_MAP_DIR} ) # 生成库需要pnc_map库 target_link_libraries(${PROJECT_NAME} PUBLIC pnc_map ) 1 2 3 4 5 6 project(pnc_map) add_library( ${PROJECT_NAME} SHARED pnc_map.cpp ) ","date":"2025-01-10T00:00:00Z","permalink":"https://zhichenf.github.io/p/cmake%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/","title":"CMake创建c++项目简明教程"},{"content":"引言 在C++11之前，标准库并不提供线程相关的支持（如std::thread、std::mutex等），因此在C++11之前创建线程池需要依赖于操作系统的线程库或第三方库，如 POSIX线程（pthread） 或 Boost.Thread。而在c++11之后，我们可以使用c++的标准库来实现线程池，从而写出跨平台的线程池。\n线程池简介 线程池的定义 线程池是一种线程管理模式，用于复用一组固定数量的线程来执行任务，而不是为每个任务都单独创建和销毁线程。通过线程池，任务被放入任务队列中，由空闲的线程依次取出并执行，从而提升性能和资源利用率。\n为什么需要线程池？ 线程创建和销毁的开销： 每次创建和销毁线程都需要占用系统资源。 在线程数量较多时，这些开销会变得显著。 系统资源限制： 一个进程中可以创建的线程数量是有限的（由系统资源决定）。 如果频繁创建过多线程，可能会导致资源耗尽。 高效的任务调度： 使用线程池可以让多个任务由有限的线程处理，避免因线程切换导致的性能下降。 空闲线程可以立即复用，减少等待时间。 控制并发量： 限制线程的数量，防止系统过载。 线程池的工作原理 初始化线程池： 创建一定数量的线程，并让它们处于等待（阻塞）状态。 任务提交： 新任务被添加到任务队列中。 任务执行： 空闲线程从任务队列中取出任务并执行。 执行完任务后，线程继续等待下一个任务。 线程池销毁： 停止线程池，等待所有线程完成任务并退出。 线程池的主要组件 任务队列： 存放待执行的任务，可以是FIFO队列或优先级队列。 每个任务通常是一个函数或可调用对象。 线程集合： 一组预创建的工作线程，用于执行任务。 同步机制： 使用锁（如std::mutex或pthread_mutex_t）保护任务队列，防止多线程竞争条件。 使用条件变量（如std::condition_variable或pthread_cond_t）来通知线程任务的到来。 线程池管理器： 提供接口来提交任务、管理线程池大小、以及终止线程池。 线程池的优点 减少资源消耗： 复用线程，避免频繁创建和销毁线程。 提高系统性能： 避免过多线程竞争CPU资源。 降低线程切换的开销。 方便任务管理： 可控制任务的执行顺序（如任务优先级）。 可根据负载动态调整线程池的大小。 提高可扩展性： 在多核处理器上，线程池能够更好地利用多核资源，实现并行化处理。 线程池的使用场景 高并发服务器： 如Web服务器、数据库服务器等，需要处理大量短时间的任务。 CPU密集型任务： 通过固定数量的线程并行处理计算任务，提高CPU利用率。 I/O密集型任务： 处理网络请求或文件I/O时，通过线程池避免阻塞。 定时任务： 周期性任务调度，例如日志清理、数据备份等。 示例：线程池的任务调度流程 应用程序提交任务。 任务被放入任务队列。 线程池中一个空闲线程取出任务并执行。 执行完成后，线程返回线程池，等待下一任务。 基于c++11的线程池的实现 task_queue类的设计 任务队列使用生产者消费者模型，将任务当作物品，每当将任务放到任务队列的时候，就会通知线程拿取任务，并让线程执行任务。 task_queue的接口如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #ifndef TASKQUEUE_H_ #define TASKQUEUE_H_ #include \u0026lt;queue\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; class TaskQueue{ //表示任务的类型 using ElemType = std::function\u0026lt;void()\u0026gt;; public: explicit TaskQueue(int que_size); ~TaskQueue() = default; auto Push(ElemType\u0026amp;\u0026amp; ptask) -\u0026gt; void; auto Pop() -\u0026gt; ElemType; [[nodiscard]] auto IsFull() const -\u0026gt; bool; [[nodiscard]] auto IsEmpty() const -\u0026gt; bool; auto WakeUp() -\u0026gt; void; private: size_t que_size_; std::queue\u0026lt;ElemType\u0026gt; que_;\t//用于存放任务，任务应当是一个void()的可调用对象 std::mutex mutex_; std::condition_variable not_full_; std::condition_variable not_empty_; bool flag_; //为了唤醒所有的工作线程，可以让while退出 }; #endif task_queue类的实现如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026#34;task_queue.h\u0026#34; TaskQueue::TaskQueue(const int que_size) : que_size_(que_size), mutex_(), not_full_(), not_empty_(), flag_(true) { } void TaskQueue::Push(ElemType\u0026amp;\u0026amp; ptask) { std::unique_lock lock(mutex_); while(IsFull()) { //等待not_full_来唤醒 not_full_.wait(lock); } que_.push(std::move(ptask)); not_empty_.notify_one(); } TaskQueue::ElemType TaskQueue::Pop() { std::unique_lock lock(mutex_); while(IsEmpty() \u0026amp;\u0026amp; flag_) { //等待not_empty_来唤醒 not_empty_.wait(lock); } if (flag_) { ElemType task = que_.front(); que_.pop(); not_full_.notify_one(); return task; } else { return nullptr; } } bool TaskQueue::IsFull() const { return que_.size() == que_size_; } bool TaskQueue::IsEmpty() const { return que_.empty(); } void TaskQueue::WakeUp() { flag_ = false; not_empty_.notify_all(); } thread_pool类的设计 thread_pool用于创建多个线程，并可以添加和获取任务，让线程去执行任务。其中有一个DoTask函数，当作线程函数，让线程执行任务。DoTask在执行任务前应当获取任务，如果没有任务，线程就会阻塞等待任务。当任务到来时，通过条件变量唤醒线程，并获取到任务task(一个可调用对象)，这时候就可以直接调用task()去执行任务。 thread_pool的接口如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #ifndef THREAD_POOL_H_ #define THREAD_POOL_H_ #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;task_queue.h\u0026#34; class ThreadPool { using Task = std::function\u0026lt;void()\u0026gt;; friend class WorkThread; public: ThreadPool(size_t thread_num, size_t que_size); ~ThreadPool() = default; auto Start() -\u0026gt; void; auto Stop() -\u0026gt; void; auto AddTask(Task\u0026amp;\u0026amp; task) -\u0026gt; void; private: auto GetTask() -\u0026gt; Task; auto DoTask() -\u0026gt; void; private: size_t thread_num_; size_t que_size_; std::vector\u0026lt;std::unique_ptr\u0026lt;std::thread\u0026gt;\u0026gt; threads_; TaskQueue task_que_; bool is_exit_; }; #endif thread_pool的实现如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026#34;thread_pool.h\u0026#34; ThreadPool::ThreadPool(const size_t thread_num, const size_t que_size) : thread_num_(thread_num), que_size_(que_size), task_que_(que_size_), is_exit_(false) { threads_.reserve(thread_num_); } void ThreadPool::Start() { for (size_t i = 0; i \u0026lt; thread_num_; i++) { threads_.push_back(std::make_unique\u0026lt;std::thread\u0026gt;(std::bind(\u0026amp;ThreadPool::DoTask,this))); } } void ThreadPool::Stop() { //确保任务队列里的任务可以执行完 while(!task_que_.IsEmpty()) { std::this_thread::sleep_for(std::chrono::seconds(1)); } std::this_thread::sleep_for(std::chrono::seconds(2)); is_exit_ = true; task_que_.WakeUp(); for (size_t i = 0; i \u0026lt; thread_num_; i++) { threads_[i]-\u0026gt;join(); } } void ThreadPool::AddTask(Task\u0026amp;\u0026amp; task) { if (task) { task_que_.Push(std::move(task)); } } ThreadPool::Task ThreadPool::GetTask() { return task_que_.Pop(); } void ThreadPool::DoTask() { while(!is_exit_) { if (Task task = GetTask()) { task(); } } } 设计上的细节 在终止线程池之前，要确保任务队列中的任务被全部取出。 当线程池终止的时候，会将退出标志设置为true，并且会唤醒所有睡着的线程，并告知退出，此时线程将不再会进入循环。 使用线程池 定义MyTask类，使用process()成员函数作为任务的具体执行过程，任务所需要的变量可以用MyTask的成员变量来表示。注意任务应当是void()类型的可调用对象，所以thread_pool添加任务的时候，需要绑定一下this指针。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026#34;thread_pool.h\u0026#34; //自己实现任务逻辑交给线程池去执行 class MyTask { public: explicit MyTask(const int num) : num_(num) {} void process() const { std::cout \u0026lt;\u0026lt; num_ \u0026lt;\u0026lt; std::endl; } char num_; }; int main() { ThreadPool pool(4, 10); std::vector\u0026lt;MyTask\u0026gt; tasks; for (int i = 0; i \u0026lt; 40; i++) { tasks.emplace_back(i+\u0026#39;A\u0026#39;); } pool.Start(); for (int i = 0; i \u0026lt; 40; i++) { pool.AddTask(std::bind(\u0026amp;MyTask::process,\u0026amp;tasks[i])); } pool.Stop(); } ","date":"2025-01-06T00:00:00Z","permalink":"https://zhichenf.github.io/p/c-11%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"C++11线程池"}]